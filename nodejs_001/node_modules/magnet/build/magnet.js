'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _metal = require('metal');

var _serverFactory = require('./server-factory');

var _serverFactory2 = _interopRequireDefault(_serverFactory);

var _metalAssertions = require('metal-assertions');

var _bodyParser = require('body-parser');

var _bodyParser2 = _interopRequireDefault(_bodyParser);

var _client = require('./build/client');

var _server = require('./build/server');

var _compression = require('compression');

var _compression2 = _interopRequireDefault(_compression);

var _config = require('./config');

var _error = require('./middleware/error');

var _express = require('express');

var _express2 = _interopRequireDefault(_express);

var _expressValidator = require('express-validator');

var _expressValidator2 = _interopRequireDefault(_expressValidator);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _webpack = require('./build/webpack');

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _helmet = require('helmet');

var _helmet2 = _interopRequireDefault(_helmet);

var _log = require('./log');

var _log2 = _interopRequireDefault(_log);

var _multer = require('multer');

var _multer2 = _interopRequireDefault(_multer);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _resolve = require('resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _validatorError = require('./middleware/validator-error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Magnet class that handle configuration, directory injection, and server.
 * @class
 */
class Magnet {
  /**
   * Constructor.
   * @param {!Object} options Magnet options.
   */
  constructor(options) {
    (0, _metalAssertions.assertDefAndNotNull)(options, `Magnet options are required, ` + `try: new Magnet({directory: \'/app\'}).`);
    (0, _metalAssertions.assertDefAndNotNull)(options.directory, `Magnet directory is required, ` + `try: new Magnet({directory: \'/app\'}).`);

    /**
     * Configuration object.
     * @type {!object}
     * @protected
     */
    this.config = Magnet.resolveConfig(options.directory, options.config, options.configDir);

    /**
     * Sync log level to the one set on this instance.
     * @type {!string}
     * @protected
     */
    _log2.default.level = this.config.magnet.logLevel;

    /**
     * Directory to start magnet application.
     * @type {!string}
     * @private
     */
    this.directory_ = options.directory;

    /**
     * Default server runtime used to handle http requests.
     * @type {!Server}
     * @private
     */
    this.server_ = _serverFactory2.default.create();

    /**
     * Magnet plugins.
     * @type {!Array}
     * @private
     */
    this.plugins_ = [];

    this.registerWebpackConfig_();
    this.registerPlugins_();
  }

  /**
   * Adds plugin.
   * @param {Object} plugin
   */
  addPlugin(plugin) {
    this.plugins_.push(plugin);
  }

  /**
   * Builds application.
   */
  async build() {
    await this.maybeBuildPlugins_();
    await (0, _client.buildClient)(this);

    const files = this.getBuildFiles({ directory: this.getDirectory() });
    if (!files.length) {
      return;
    }

    await (0, _server.buildServer)(files, this.getDirectory(), this.getServerDistDirectory(), this.getPlugins(), this.getConfig());
  }

  /**
   * Gets config.
   * @return {Object}
   */
  getConfig() {
    return this.config;
  }

  /**
   * Gets directory.
   * @return {string}
   */
  getDirectory() {
    return this.directory_;
  }

  /**
   * Scans files that matches with `config.magnet.src` globs.
   * excluding `config.magnet.ignore`.
   * @param {!string} directory
   * @param {?boolean} realpath Whether should return the files real path.
   * @param {?array.<string>} src
   * @param {?array.<string>} ignore
   * @return {array.<string>} Array of file paths.
   */
  getFiles({
    directory,
    realpath = false,
    src = this.config.magnet.src,
    ignore = this.config.magnet.ignore
  }) {
    let files = [];
    src.forEach(pattern => {
      files = files.concat(_glob2.default.sync(pattern, { cwd: directory, ignore: ignore, realpath: realpath }));
    });
    if (!realpath) {
      // Normalize globs of relative paths to start with './'.
      files = files.map(file => {
        if (_path2.default.isAbsolute(file)) {
          return file;
        }
        return '.' + _path2.default.sep + _path2.default.join(file);
      });
    }
    return [...new Set(files)];
  }

  /**
   * Scans files that matches with `config.magnet.src` globs.
   * excluding `config.magnet.ignore`, beforeStart.js,
   * start.js, afterStart.js and stop.js.
   * @return {Array.<string>} Array of file paths.
   */
  getLoadFiles() {
    const directory = this.getServerDistDirectory();
    return this.getFiles({ directory, realpath: true }).filter(function (item) {
      switch (item) {
        case _path2.default.join(directory, Magnet.LifecyleFiles.BEFORE_START):
        case _path2.default.join(directory, Magnet.LifecyleFiles.START):
        case _path2.default.join(directory, Magnet.LifecyleFiles.AFTER_START):
        case _path2.default.join(directory, Magnet.LifecyleFiles.STOP):
          return false;
        default:
          return true;
      }
    });
  }

  /**
   * Scans files that matches with `config.magnet.src` globs.
   * excluding `config.magnet.ignore`, adding beforeStart.js,
   * start.js, afterStart.js and stop.js.
   * @return {Array.<string>} Array of file paths.
   */
  getBuildFiles() {
    const directory = this.getDirectory();
    const src = this.config.magnet.src.concat([Magnet.LifecyleFiles.BEFORE_START, Magnet.LifecyleFiles.START, Magnet.LifecyleFiles.AFTER_START, Magnet.LifecyleFiles.STOP]);
    return this.getFiles({ directory, src });
  }

  /**
   * Returns magnet plugins.
   * @return {Array.<Object>}
   * @protected
   */
  getPlugins() {
    return this.plugins_;
  }

  /**
   * Gets server runtime.
   * @return {Server}
   */
  getServer() {
    return this.server_;
  }

  /**
   * Gets server dist directory.
   * @return {string}
   */
  getServerDistDirectory() {
    return _path2.default.join(this.directory_, '.magnet', 'server');
  }

  /**
   * Gets static files dist directory.
   * @return {string}
   */
  getStaticDistDirectory() {
    return _path2.default.join(this.directory_, 'static');
  }

  /**
   * Checks if server dist directory exists.
   * @return {boolean}
   */
  hasServerDistDirectory() {
    try {
      _fsExtra2.default.accessSync(this.getServerDistDirectory());
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Loads application.
   * @protected
   */
  async load() {
    let dist = this.getServerDistDirectory();
    let files = this.getLoadFiles({ directory: dist, realpath: true });

    for (const file of files) {
      let module = require(file);
      try {
        for (const plugin of this.getPlugins()) {
          if (plugin.test(module, file, this)) {
            plugin.register(module, file, this);
            break;
          }
        }
      } catch (error) {
        _log2.default.error(false, error);
      }
    }
  }

  /**
   * Maybe build plugins.
   * @param {Magnet} magnet
   * @private
   */
  async maybeBuildPlugins_() {
    try {
      for (const plugin of this.getPlugins()) {
        if ((0, _metal.isFunction)(plugin.build)) {
          await plugin.build(this);
        }
      }
    } catch (error) {
      _log2.default.error(false, error);
    }
  }

  /**
   * Maybe run lifecycle file.
   * @param {!string} lifecycleFile
   * @private
   */
  async maybeRunLifecycleFile_(lifecycleFile) {
    let file = _path2.default.resolve(this.getServerDistDirectory(), lifecycleFile);
    if (_fsExtra2.default.existsSync(file)) {
      let fn = require(file);
      if (fn.default) {
        fn = fn.default;
      }
      if ((0, _metal.isFunction)(fn)) {
        let app = this.getServer().getEngine();
        fn.call(this, app, this);
      }
    }
  }

  /**
   * Register magnet plugins.
   * @private
   */
  registerPlugins_() {
    const config = this.getConfig();
    const pluginPrefix = 'magnet-plugin-';

    for (let plugin of config.magnet.plugins) {
      if ((0, _metal.isString)(plugin)) {
        const resolvedPath = _resolve2.default.sync(`${pluginPrefix}${plugin}`, {
          basedir: process.cwd()
        });
        plugin = require(resolvedPath);
      }

      if (plugin.default) {
        plugin = plugin.default;
      }
      this.addPlugin(plugin);
    }
  }

  /**
   * Resolves configuration using environment `NODE_ENV` or the specified
   * `config` filename. Note that the configuration directory can be specified
   * as `configDir`.
   * @param {!string} directory
   * @param {?string=} config Optional config filename.
   * @param {?string=} configDir Optional config directory.
   * @param {?boolean=} showLog Display log of loaded config filename.
   * @return {Object} Configuration object.
   * @static
   */
  static resolveConfig(directory, config, configDir = '', showLog = true) {
    let lookupConfig = config;
    // Try loading config from environment...
    if (!lookupConfig) {
      let envConfig = `magnet.${process.env.NODE_ENV}.config.js`;
      if (_fsExtra2.default.existsSync(_path2.default.resolve(directory, configDir, envConfig))) {
        lookupConfig = envConfig;
      }
    }
    // If still not found, try loading default filename.
    if (!lookupConfig) {
      lookupConfig = 'magnet.config.js';
    }
    if (showLog) {
      _log2.default.info(false, 'Using ' + lookupConfig);
    }
    return (0, _config.createConfig)(directory, lookupConfig, configDir);
  }

  /**
   * Setup body parser middleware.
   * @private
   */
  setupMiddlewareBodyParser_() {
    this.getServer().getEngine().use(_bodyParser2.default.urlencoded({ extended: false }));

    this.getServer().getEngine().use(_bodyParser2.default.json());
  }

  /**
   * Setup compression middleware.
   * @private
   */
  setupMiddlewareCompression_() {
    this.getServer().getEngine().use((0, _compression2.default)());
  }

  /**
   * Setup error middleware.
   * @private
   */
  setupMiddlewareError_() {
    this.getServer().getEngine().use((0, _validatorError.validatorErrorMiddleware)());
    this.getServer().getEngine().use((0, _error.errorMiddleware)());
  }

  /**
   * Setup http logger middleware.
   * @private
   */
  setupMiddlewareHttpLogger_() {
    switch (this.config.magnet.logLevel) {
      case 'silent':
        return;
    }
    if (this.config.magnet.requestLogger) {
      this.getServer().getEngine().use(this.config.magnet.requestLogger);
    }
  }

  /**
   * Setup multipart form data parser middleware.
   * @private
   */
  setupMiddlewareMultipart_() {
    this.getServer().getEngine().use((0, _multer2.default)().any());
  }

  /**
   * Setup validator middleware.
   * @private
   */
  setupMiddlewareValidator_() {
    this.getServer().getEngine().use((0, _expressValidator2.default)({
      customValidators: {
        custom: function (value, fn) {
          return fn(value);
        }
      },
      errorFormatter: (param, msg, value) => {
        return {
          reason: msg,
          context: {
            param: param,
            value: value
          }
        };
      }
    }));
  }

  /**
   * Setup engine application settings.
   * @private
   */
  setupApplicationSettings_() {
    this.getServer().getEngine().set('trust proxy', true);
  }

  /**
   * Setup engine middleware.
   * @private
   */
  setupMiddlewares_() {
    if (this.getConfig().magnet.dev) {
      this.setupMiddlewareDevelopment_();
    }
    this.setupMiddlewareSecurity_();
    this.setupMiddlewareBodyParser_();
    this.setupMiddlewareMultipart_();
    this.setupMiddlewareCompression_();
    this.setupMiddlewareHttpLogger_();
    this.setupMiddlewareValidator_();
    this.setupMiddlewareStaticFiles_();
  }

  /**
   * Setup security middleware.
   * @private
   */
  setupMiddlewareSecurity_() {
    this.getServer().getEngine().use((0, _helmet2.default)());
  }

  /**
   * Setup development middleware.
   * @private
   */
  setupMiddlewareDevelopment_() {
    this.getServer().getEngine().use((req, res, next) => {
      res.set('Connection', 'close');
      next();
    });
  }

  /**
   * Setup static files middleware.
   * @private
   */
  setupMiddlewareStaticFiles_() {
    this.getServer().getEngine().use('/static', _express2.default.static(this.getStaticDistDirectory()));
  }

  /**
   * Register default webpack config.
   */
  registerWebpackConfig_() {
    this.webpackConfig = (0, _webpack.getDefaultWebpackConfig)(this);
  }

  /**
   * Starts plugins by calling their `start` method.
   * @private
   */
  async startPlugins() {
    _log2.default.info(false, 'Starting plugins…');

    try {
      for (const plugin of this.getPlugins()) {
        if ((0, _metal.isFunction)(plugin.start)) {
          await plugin.start(this);
        }
      }
    } catch (error) {
      _log2.default.error(false, error);
    }
  }

  /**
   * Starts application.
   */
  async start() {
    this.maybeRunLifecycleFile_(Magnet.LifecyleFiles.BEFORE_START);

    this.setupMiddlewares_();
    this.setupApplicationSettings_();

    this.maybeRunLifecycleFile_(Magnet.LifecyleFiles.START);

    await this.startPlugins();
    await this.load();

    this.setupMiddlewareError_();

    this.maybeRunLifecycleFile_(Magnet.LifecyleFiles.AFTER_START);

    await new Promise((resolve, reject) => {
      this.getServer().getHttpServer().on('error', reject);
      this.getServer().setPort(this.config.magnet.port).setHost(this.config.magnet.host).getHttpServer().on('listening', () => resolve());
      this.getServer().listen();
    });
  }

  /**
   * Stops application.
   */
  async stop() {
    _log2.default.info(false, 'Shutting down gracefully…');
    this.maybeRunLifecycleFile_(Magnet.LifecyleFiles.STOP);
    await this.getServer().close();
  }
}

/**
 * Magnet lifecycle files.
 * @static
 * @enum {string}
 */
Magnet.LifecyleFiles = {
  BEFORE_START: 'beforeStart.js',
  START: 'start.js',
  AFTER_START: 'afterStart.js',
  STOP: 'stop.js'
};

exports.default = Magnet;